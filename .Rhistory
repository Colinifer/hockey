binned.frac=bin.goals/bin.shots,
bin.shots=bin.shots,
bin.goals=bin.goals,
superbin.shots=superbin.shots,
superbin.goals=superbin.goals
))
}
shot.bin.set.blocks <- function (event.df,
scatter.grid=point.grid(),
coordnames=c("ycoord","xcoord")
, use.superblocks=FALSE
) {
#message(coordnames)
all.shots <- nhl.zonebin.prime(nhl.hexbin (event.df[,coordnames], scatter.grid),
scatter.grid, use.superblocks)
all.goals <- nhl.zonebin.prime(nhl.hexbin (subset(event.df, etype=="GOAL")[,coordnames], scatter.grid),
scatter.grid, use.superblocks)
return(cbind(all.shots=all.shots,
all.goals=all.goals))
}
View(hexagon.coords.auto)
#########################################################################
#
# Goldsberry plot of NHL shot data
#
#######################################################################
#Make hexagons.
#turn90 <- function (nby2) cbind(nby2[,2], -nby2[,1])
three.superblocks <- function () c(1,1,1,
1,2,2,2,1,
1,2,3,3,2,1,
1,1)
ordinal.maker <- function (vec, cuts=quantile(vec, c(0, 0.35, 0.7), na.rm=TRUE)) {
#vec=0:20; cuts=cutoffs
apply(1*outer (vec, cuts, ">="), 1, sum, na.rm=TRUE)
}
ordinal.maker.zeroes <- function (vec, cuts=quantile(vec[vec>0], c(0, 0.35, 0.7))) {
#vec=0:20; cuts=cutoffs
r1 <- 0*vec
r1[vec>0] <- apply(1*outer (vec[vec>0], cuts, ">="), 1, sum, na.rm=TRUE)
r1
}
hexagon.coords.single <- function (x=0, y=0, radius=2.01) {
coords <- t(radius*rbind(x=c(1,1,0,-1,-1,0),
y=c(1/sqrt(3), -1/sqrt(3), -2/sqrt(3), -1/sqrt(3), 1/sqrt(3), 2/sqrt(3))) + c(x,y))
coords
}
hexagon.coords.auto <- function (xygrid, relative.size=0.8) {
output <- matrix(NA, nrow=nrow(xygrid)*7, ncol=2)
new.size <- relative.size*max(abs(xygrid[1,1] - xygrid[2,1]), abs(xygrid[1,2] - xygrid[2,2]))/2
for (kk in 1:nrow(xygrid))
output[1:6 + (kk-1)*7,] <- hexagon.coords.single (xygrid[kk,1],
xygrid[kk,2],
new.size)
return(output)
}
hexagon.coords.ordinal <- function (scatter.grid, sizes) {
#print(sizes)
new.size <- rep(0, length(sizes))
new.size[sizes >= 1] <- new.size[sizes >= 1] + 0.3
new.size[sizes >= 2] <- new.size[sizes >= 2] + 0.3
new.size[sizes >= 3] <- new.size[sizes >= 3] + 0.3
new.size <- new.size * scatter.grid$radius
output <- matrix(NA, nrow=length(sizes)*7, ncol=2)
for (kk in 1:length(sizes))
output[1:6 + (kk-1)*7,] <- hexagon.coords.single (scatter.grid$grid[kk,1],
scatter.grid$grid[kk,2],
new.size[kk])
return(output)
}
hexagon.coords <- function (...) hexagon.coords.ordinal(...)
#######################################################################
#Bin into quadrilaterals.
in.triangle <- function (xyp, tr) {
area <- (-tr[5]*tr[3] + tr[4]*(tr[3]-tr[2]) + tr[1]*(-tr[6]+tr[5]) + tr[2]*tr[6])/2
ss <- 1/2/area * (tr[4]*tr[3] - tr[1]*tr[6] + (tr[6]-tr[4])*xyp[,1] + (tr[1]-tr[3])*xyp[,2])
tt <- 1/2/area * (tr[1]*tr[5] - tr[4]*tr[2] + (tr[4]-tr[5])*xyp[,1] + (tr[2]-tr[1])*xyp[,2])
output <- (ss > 0 & tt > 0 & 1 > ss+tt)
return(output)
}
in.tri.rev <- function (tr=matrix(c(0,0.5,1, 0,1,0), nrow=3), xy.points) in.triangle (xy.points, tr)
pick.section.side <- function (xy.points) {
data(quadsarrayplot)
in.1 <- apply(quadsarrayplot[1:3,,], 3, in.tri.rev, xy.points)
in.2 <- apply(quadsarrayplot[c(1,3,4),,], 3, in.tri.rev, xy.points)
picks <- in.1 | in.2
picks[is.na(picks)] <- FALSE
picker <- function (row) if (sum(row)>0) min(which(row)) else 0
sections <- apply (picks, 1, picker)
return(sections)
}
############################################################################
# Point grid for binning.
point.grid <- function (xbins=31, xrange=c(-42.5, 42.5), yrange=c(-1,100)) {
radius <- 85/(2*xbins)
initial.x <- seq(xrange[1]+radius, xrange[2]-radius, length=xbins)
shifted.x <- seq(xrange[1], xrange[2], length=xbins+1)
yvalue <- yrange[1]+0.01
scatter.grid <- NULL
while (yvalue < yrange[2]) {
scatter.grid <- rbind(scatter.grid,
cbind(initial.x, yvalue),
cbind(shifted.x, yvalue + sqrt(3)*radius))
yvalue <- yvalue + sqrt(3)*radius*2
}
scatter.grid <- data.frame(plotting.x=scatter.grid[,1], plotting.y=scatter.grid[,2])
scatter.grid <- subset(scatter.grid, plotting.y < yrange[2])
uniques <- t(expand.grid(xx=(-42):42, yy=0:100))
dist2 <- function (single.plot) which.min((scatter.grid[,1] - single.plot[1])^2 +
(scatter.grid[,2] - single.plot[2])^2)
bins <- apply(uniques, 2, dist2)
zone.section <- pick.section.side (scatter.grid)
zone.section.bigblock <- three.superblocks()[zone.section]
output <- list(grid=scatter.grid,
uniques=cbind(t(uniques), bins),
zone.section=zone.section,
zone.unique=1:max(zone.section),
zone.section.bigblock=zone.section.bigblock,
zone.bigblock.unique=1:max(zone.section.bigblock),
xbins=xbins,
radius=radius)
return(output)
}
###################################################################################
# Actual binning.
# must go faster!
hexbin.quick <- function (xycoords, scatter.grid) {
#xycoords = subdata[,c("newyc","newxc")]
code.u <- scatter.grid$uniques[,1] + 100*scatter.grid$uniques[,2]
code.xy <- xycoords[,1] + 100*xycoords[,2]
scatter.grid$uniques[match(code.xy, code.u),3]
##return(table.complete(bins.2, nrow(scatter.grid$grid)))
}
table.complete <- function (vec, count) sapply(1:count, function (cc) sum(vec==cc, na.rm=TRUE))
nhl.hexbin <- function (xycoords, scatter.grid) {
code.u <- scatter.grid$uniques[,1] + 100*scatter.grid$uniques[,2]
code.xy <- xycoords[,1] + 100*xycoords[,2]
bins.2 <- scatter.grid$uniques[match(code.xy, code.u),3]
return(table.complete(bins.2, nrow(scatter.grid$grid)))
}
nhl.zonebin.prime <- function (bin.counts, scatter.grid, use.superblocks=FALSE) {
#sum up over bins in each zone. Redistribute over bins.
if (use.superblocks) {
retval <- sapply(scatter.grid$zone.bigblock.unique, function(bb)
sum(bin.counts[scatter.grid$zone.section.bigblock == bb], na.rm=TRUE))
} else {
retval <- sapply(scatter.grid$zone.unique, function(bb)
sum(bin.counts[scatter.grid$zone.section == bb], na.rm=TRUE))
}
return(retval)
}
nhl.zonebin <- function (bin.counts, scatter.grid, use.superblocks=FALSE) {
#sum up over bins in each zone. Redistribute over bins.
bin.overall <- nhl.zonebin.prime (bin.counts, scatter.grid, use.superblocks)
output <- rep(NA, nrow(scatter.grid$grid))
if (use.superblocks) {
for (bb in 1:length(bin.overall)) output[scatter.grid$zone.section.bigblock == bb] <- bin.overall[bb]
} else {
for (bb in 1:length(bin.overall)) output[scatter.grid$zone.section == bb] <- bin.overall[bb]
}
output
}
rink.hexplot <- function (scatter.grid, sizes, colors, bordercolor=NA, ...) {
#sizes is now ordinal: 0=none, 1=0.4, 2=0.8, 3=0.8 black border
par(mar=c(0, 0, 3, 0))
rink.plot(...) #...)
hex.coords <- hexagon.coords.ordinal(scatter.grid, sizes)
colors[sizes==0] <- 0
bordercolor <- rep(bordercolor, length(colors)); bordercolor[sizes == 0] <- NA
polygon(hex.coords, col=colors, border=bordercolor, lwd=2)
}
rink.hexplot.auto <- function (scatter.grid, sizes, colors, ...) {
rink.hexplot (scatter.grid, sizes=ordinal.maker.zeroes(sizes), colors, ...)
}
shot.bin.set <- function (event.df,
scatter.grid=point.grid(),
coordnames=c("ycoord","xcoord")) {
## event.df=player.events; coordnames=coordset()
#message(coordnames)
all.shots <- nhl.hexbin (event.df[,coordnames], scatter.grid)
all.goals <- nhl.hexbin (subset(event.df, etype=="GOAL")[,coordnames], scatter.grid)
bin.shots <- nhl.zonebin (all.shots, scatter.grid)
bin.goals <- nhl.zonebin (all.goals, scatter.grid)
superbin.shots <- nhl.zonebin (all.shots, scatter.grid, use.superblocks=TRUE)
superbin.goals <- nhl.zonebin (all.goals, scatter.grid, use.superblocks=TRUE)
return(cbind(all.shots=all.shots,
all.goals=all.goals,
binned.frac=bin.goals/bin.shots,
bin.shots=bin.shots,
bin.goals=bin.goals,
superbin.shots=superbin.shots,
superbin.goals=superbin.goals
))
}
shot.bin.set.blocks <- function (event.df,
scatter.grid=point.grid(),
coordnames=c("ycoord","xcoord")
, use.superblocks=FALSE
) {
#message(coordnames)
all.shots <- nhl.zonebin.prime(nhl.hexbin (event.df[,coordnames], scatter.grid),
scatter.grid, use.superblocks)
all.goals <- nhl.zonebin.prime(nhl.hexbin (subset(event.df, etype=="GOAL")[,coordnames], scatter.grid),
scatter.grid, use.superblocks)
return(cbind(all.shots=all.shots,
all.goals=all.goals))
}
faceoff.circle = function (x,y, thiscol="red") {
theta = seq(0,2*pi,length=300)
#outer.
polygon (x + 15*cos(theta),
y + 15*sin(theta),
lwd=2,
border=thiscol)
polygon (x + 1*cos(theta),
y + 1*sin(theta),
col=thiscol,
border=thiscol)
segments (c(x-0.75,x-0.75, x+0.75,x+0.75, x-0.75,x-0.75, x+0.75,x+0.75),
c(y-2,y-2, y-2,y-2, y+2,y+2,y+2,y+2),
c(x-0.75,x-3.75, x+0.75,x+3.75, x-0.75,x-3.75, x+0.75,x+3.75),
c(y-6,y-2, y-6,y-2, y+6,y+2,y+6,y+2),
col=thiscol, lwd=2)
dd <- (5+7/12)/2
segments (c(x-15, x-15, x+15, x+15),
c(y-dd, y+dd, y-dd, y+dd),
c(x-17, x-17, x+17, x+17),
c(y-dd, y+dd, y-dd, y+dd),
col=thiscol, lwd=2)
}
goal.crease = function (flip=1, fillcol="lightblue", thiscol="red") {
xseq = seq(-4,4,length=100)
polygon (c(-4, xseq, 4),
flip*c(89, 83+xseq^2/4^2*1.5, 89),
col=fillcol, border=thiscol)
}
rink.plot.blank = function (...) {
plot(c(42.6,-42.6), c(101,0), ty="n", ylim=c(101,25), xlim=c(-42.6, 42.6), ylab="", xlab="", axes=FALSE, ...)
}
rink.plot = function (fresh=TRUE, thiscol="red", ...) {
if (fresh) rink.plot.blank (...)
rect(-42.5, 25, 42.5, 26, col=4, border=4)
lines (c(-42.5,
-42.5 + 28 - 28*cos(seq(0,pi/2,length=20)),
42.5 - 28 + 28*cos(seq(pi/2,0,length=20)),
42.5),
c(15,
72 + 28*sin(seq(0,pi/2,length=20)),
72 + 28*sin(seq(pi/2,0,length=20)),
15),
col=1, lwd=2)
goal.line.extreme = 42.5 - 28 + sqrt(28^2 - (28-11)^2)
lines(goal.line.extreme*c(-1, 1), rep(89,2), col=thiscol, lwd=2)        #the goal line.
lines(c(-3,-3,3,3), c(90,92,92,90)-1, col=1, lwd=3)    #the goal net.
goal.crease(thiscol=thiscol)
segments(c(-11, 11), c(89,89), c(-14,14), c(100,100), col=thiscol, lwd=2)
faceoff.circle (-22, 69, thiscol)
faceoff.circle (22, 69, thiscol)
}
full.rink = function () {
theta = seq(0,2*pi,length=300)
par(mar=c(0,0,0,0))
plot(c(-42.6, 42.6), c(-101,101), ty="n", ylim=c(-101,101), xlim=c(-42.6, 42.6), ylab="", xlab="", axes=FALSE)
polygon (15*cos(theta), 15*sin(theta), lwd=2, border=4)
theta2 = seq (pi/2, 3*pi/2, length=300)
polygon (42.5 + 10*cos(theta2), 10*sin(theta2), lwd=2, border=2)
rect(-42.5, 25, 42.5, 26, col=4, border=4)
rect(-42.5, -25, 42.5, -26, col=4, border=4)
rect(-42.5, -0.5, 42.5, 0.5, col=2, border=2)
lines (c(-42.5,
-42.5 + 28 - 28*cos(seq(0,pi/2,length=20)),
42.5 - 28 + 28*cos(seq(pi/2,0,length=20)),
42.5),
c(15,
72 + 28*sin(seq(0,pi/2,length=20)),
72 + 28*sin(seq(pi/2,0,length=20)),
15),
col=1, lwd=2)
lines (c(-42.5,
-42.5 + 28 - 28*cos(seq(0,pi/2,length=20)),
42.5 - 28 + 28*cos(seq(pi/2,0,length=20)),
42.5),
c(15,
-72 - 28*sin(seq(0,pi/2,length=20)),
-72 - 28*sin(seq(pi/2,0,length=20)),
15),
col=1, lwd=2)
goal.line.extreme = 42.5 - 28 + sqrt(28^2 - (28-11)^2)
lines(goal.line.extreme*c(-1, 1), rep(89,2), col=2,lwd=2)        #the goal line.
lines(goal.line.extreme*c(-1, 1), rep(-89,2), col=2,lwd=2)        #the goal line.
lines(c(-3,-3,3,3), c(90,92,92,90)-1, col=1, lwd=3)    #the goal net.
lines(c(-3,-3,3,3), -(c(90,92,92,90)-1), col=1, lwd=3)    #the goal net.
goal.crease(); goal.crease(-1)
## traps.
segments(c(-11, 11, -11, 11), c(89,89,-89,-89),
c(-14,14,-14,14), c(100,100, -100,-100), col=2, lwd=2)
faceoff.circle (-22, 69)
faceoff.circle (22, 69)
faceoff.circle (-22, -69)
faceoff.circle (22, -69)
faceoff.dot = function (x,y) {
polygon (x + 1*cos(theta),
y + 1*sin(theta),
col=2,
border=2)
}
faceoff.dot (22,20); faceoff.dot (22,-20); faceoff.dot (-22,20); faceoff.dot (-22,-20);
}
full.rink()
png("full-rink.png", width=860, height=2050); full.rink(); dev.off()
faceoff.circle
theta = seq(0,2*pi,length=300)
par(mar=c(0,0,0,0))
plot(c(-42.6, 42.6), c(-101,101), ty="n", ylim=c(-101,101), xlim=c(-42.6, 42.6), ylab="", xlab="", axes=FALSE)
polygon (15*cos(theta), 15*sin(theta), lwd=2, border=4)
theta2 = seq (pi/2, 3*pi/2, length=300)
polygon (42.5 + 10*cos(theta2), 10*sin(theta2), lwd=2, border=2)
rect(-42.5, 25, 42.5, 26, col=4, border=4)
rect(-42.5, -25, 42.5, -26, col=4, border=4)
rect(-42.5, -0.5, 42.5, 0.5, col=2, border=2)
lines (c(-42.5,
-42.5 + 28 - 28*cos(seq(0,pi/2,length=20)),
42.5 - 28 + 28*cos(seq(pi/2,0,length=20)),
42.5),
c(15,
72 + 28*sin(seq(0,pi/2,length=20)),
72 + 28*sin(seq(pi/2,0,length=20)),
15),
col=1, lwd=2)
lines (c(-42.5,
-42.5 + 28 - 28*cos(seq(0,pi/2,length=20)),
42.5 - 28 + 28*cos(seq(pi/2,0,length=20)),
42.5),
c(15,
-72 - 28*sin(seq(0,pi/2,length=20)),
-72 - 28*sin(seq(pi/2,0,length=20)),
15),
col=1, lwd=2)
goal.line.extreme = 42.5 - 28 + sqrt(28^2 - (28-11)^2)
lines(goal.line.extreme*c(-1, 1), rep(89,2), col=2,lwd=2)        #the goal line.
lines(goal.line.extreme*c(-1, 1), rep(-89,2), col=2,lwd=2)        #the goal line.
lines(c(-3,-3,3,3), c(90,92,92,90)-1, col=1, lwd=3)    #the goal net.
lines(c(-3,-3,3,3), -(c(90,92,92,90)-1), col=1, lwd=3)    #the goal net.
goal.crease(); goal.crease(-1)
## traps.
segments(c(-11, 11, -11, 11), c(89,89,-89,-89),
c(-14,14,-14,14), c(100,100, -100,-100), col=2, lwd=2)
faceoff.circle (-22, 69)
faceoff.circle (22, 69)
faceoff.circle (-22, -69)
faceoff.circle (22, -69)
faceoff.dot = function (x,y) {
polygon (x + 1*cos(theta),
y + 1*sin(theta),
col=2,
border=2)
}
faceoff.dot (22,20); faceoff.dot (22,-20); faceoff.dot (-22,20); faceoff.dot (-22,-20);
proj_name <- "hockey"
# devtools::install_github('bbc/bbplot')
pkgs <- c(
"devtools",
"tidyverse",
"RMariaDB",
"DBI",
"readr",
"pander",
"na.tools",
"ggimage",
"devtools",
"teamcolors",
"glue",
"dplyr",
"RCurl",
"tictoc",
"animation",
"gt",
"DT",
"ggthemes",
"bbplot",
"ggtext",
"ggforce",
"ggridges",
"ggrepel",
"ggbeeswarm",
"extrafont",
"RCurl",
"xml2",
"rvest",
"jsonlite",
"foreach",
"lubridate",
"snakecase",
"nhlapi"
)
installed_packages <- pkgs %in%
rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(pkgs[!installed_packages])
}
if (any("bbplot" %in%
rownames(installed.packages()) == FALSE)) {
library(devtools)
devtools::install_github('bbc/bbplot')
}
invisible(lapply(pkgs, library, character.only = TRUE))
rm(pkgs, installed_packages)
# Initialize Working Directory --------------------------------------------
source("../initR/init.R")
fx.setdir(proj_name)
# Create standard objects -------------------------------------------------
f.con <- "../initR/con.R"
source(f.con)
dbListTables(con)
dbDisconnect(con)
pbp_scrape <- readRDS("data/pbp_scrape3.rds")
str(pbp_scrape, 1)
purrr::pluck(pbp_scrape, 1)
purrr::pluck(pbp_scrape)
purrr::pluck(pbp_scrape, 1)
x <- pbp_scrape[1] %>% names()
grep(x, names(scrape)
)
grep(x, names(pbp_scrape))
pbp_scrapep[1]
pbp_scrape[1]
dbListTables(con)
source(f.con)
table_names <- dbListTables(con)
dbDisconnect(con)
table_names[grep(x, names(scrape))]
table_names[grep(x, names(pbp_scrape))]
grep(x, names(scrape)) + 5
grep(x, names(pbp_scrape)) + 5
table_names[6]
table_names[7]
table_names[8]
table_names[9]
table_names[10]
table_names[11]
grep(x, names(scrape)) + nrow(names(pbp_scrape))
grep(x, names(pbp_scrape)) + nrow(names(pbp_scrape))
nrow(names(pbp_scrape))
grep(x, names(pbp_scrape)) + length(names(pbp_scrape))
table_names[grep(x, names(pbp_scrape)) + length(names(pbp_scrape))]
table_names[grep(x, names(pbp_scrape)) + length(names(pbp_scrape)) + 1]
table_names[grep(x, names(pbp_scrape)) + length(names(pbp_scrape)) + 2]
table_names[grep(x, names(pbp_scrape)) + length(names(pbp_scrape)) + 1]
table_names[grep(x, names(pbp_scrape)) + length(names(pbp_scrape))]
table_names
names(pbp_scrape)
table_names[grep(x, names(pbp_scrape)) + length(names(pbp_scrape)) + 1]
grep(x, names(pbp_scrape))
grep(x, names(table_names))
grep(x, table_names)
length(names(pbp_scrape)) + 1
table_names[grep(x, table_names) + length(names(pbp_scrape)) + 1]
table_names[grep(x, table_names)]
rm(pbp_scrape)
proj_name <- "hockey"
# devtools::install_github('bbc/bbplot')
pkgs <- c(
"devtools",
"tidyverse",
"RMariaDB",
"DBI",
"readr",
"pander",
"na.tools",
"ggimage",
"devtools",
"teamcolors",
"glue",
"dplyr",
"RCurl",
"tictoc",
"animation",
"gt",
"DT",
"ggthemes",
"bbplot",
"ggtext",
"ggforce",
"ggridges",
"ggrepel",
"ggbeeswarm",
"extrafont",
"RCurl",
"xml2",
"rvest",
"jsonlite",
"foreach",
"lubridate",
"snakecase",
"nhlapi"
)
installed_packages <- pkgs %in%
rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(pkgs[!installed_packages])
}
if (any("bbplot" %in%
rownames(installed.packages()) == FALSE)) {
library(devtools)
devtools::install_github('bbc/bbplot')
}
invisible(lapply(pkgs, library, character.only = TRUE))
rm(pkgs, installed_packages)
# Initialize Working Directory --------------------------------------------
source("../initR/init.R")
fx.setdir(proj_name)
source("EH_scrape_functions.R")
